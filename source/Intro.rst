Введение и основные понятия
----------------------------

**Arenadata Streaming (ADS) -- платформа распределенных потоковых операций**

Введение в Arenadata Streaming
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Arenadata Streaming (ADS)** -- платформа распределенных потоковых операций. Что именно это значит?

Платформа потоковой передачи данных имеет три ключевые возможности:

+ Публикация и подписка на потоковую передачу данных, похожую на очередь сообщений или корпоративную систему обмена сообщениями;
+ Хранение потоков записей отказоустойчивым способом;
+ Обработка потоков записей по мере их возникновения.

**ADS**, как правило, используется для двух обширных классов приложений:

+ Создание канала для потоковой передачи данных в реальном времени с целью надежного обмена данными между системами и приложениями;
+ Создание приложений для потоковой передачи данных в реальном времени с целью их преобразования и взаимодействия с другими потоками.

Чтобы понять, как **Arenadata Streaming** все это осуществляет, следует погрузиться и изучить возможности **ADS** снизу вверх.

Несколько концепций **Arenadata Streaming**:

+ **ADS** запускается как кластер на одном или нескольких серверах, которые могут располагаться в нескольких центрах обработки данных;
+ В кластере **ADS** потоки записей хранятся по категориям, называемым *topics* (топики);
+ Каждая запись состоит из ключа, значения и временной метки.

**ADS** имеет четыре основных **API** (`API <http://docs.arenadata.io/adh/v1.4/Streaming/API.html>`_, :numref:`Рис.%s.<ADS_intro_API>`):

+ Producer API (поставщик) позволяет приложению публиковать поток записей по одному или нескольким топикам платформы;
+ Consumer API (потребитель) позволяет приложению подписываться на один или несколько топиков и обрабатывать принадлежащие им потоки записей;
+ Streams API позволяет приложению выступать в качестве *stream processor* (потокового процессора), потребляя входной поток данных из одного или нескольких топиков и создавая выходной поток данных так же для одного или нескольких топиков, эффективно преобразуя входные потоки в выходные;
+ Connector API позволяет создавать и запускать повторное использование поставщиков и потребителей, которые связывают топики с существующими приложениями или системами данных. Например, коннектор для реляционной базы данных может записывать каждое изменение в таблицу.


.. _ADS_intro_API:

.. figure:: ./imgs/ADS_intro_API.*
   :align: center

   API к платформе ADS


В **ADS** связь между клиентами и серверами осуществляется с помощью простого, высокопроизводительного протокола **TCP**. Протокол является версионным и поддерживает обратную совместимость с предыдущими версиями. **Arenadata** предоставляет Java-клиент для **ADS**, при этом клиенты доступны на многих языках программирования (ссылка на https://cwiki.apache.org/confluence/display/KAFKA/Clients).


Концепция хранения
^^^^^^^^^^^^^^^^^^^

Для начала в главе описывается основная абстракция, которую **ADS** обеспечивает для потока записей -- топик.

Топики -- это категории, по которым записи публикуются в платформе. В **ADS** топики могут иметь нескольких потребителей, которые подписываются на получение находящихся в них данных. Для каждого топика платформа поддерживает партиционированный журнал, схематично представленный на :numref:`Рис.%s.<ADS_intro_Topic>`

.. _ADS_intro_Topic:

.. figure:: ./imgs/ADS_intro_Topic.*
   :align: center

   Париционированный журнал 

Каждая партиция представляет собой упорядоченную неизменяемую последовательность записей, которая постоянно добавляется в структурированный журнал. Каждой записи в партиции присваивается порядковый номер *id*, называемый смещением (*offset*), который однозначно идентифицирует каждую запись.

Платформа **ADS** надежно сохраняет все опубликованные записи с настройкой периода их хранения. Например, если политика хранения установлена на два дня, то в течение двух дней после публикации запись доступна для потребления, после чего она удаляется с целью освобождения места. Производительность **ADS** фактически постоянна по отношению к размеру данных, поэтому хранение данных в течение длительного времени не является проблемой (:numref:`Рис.%s.<ADS_intro_offset>`).

.. _ADS_intro_offset:

.. figure:: ./imgs/ADS_intro_offset.*
   :align: center

   Логика смещения 

Фактически, метаданные, сохраненные для каждого потребителя, являются смещением или положением потребителя в журнале. Это смещение контролируется самим потребителем: обычно потребитель линейно продвигает свое смещение при считывании записи, но так как позиция контролируется потребителем, он может считывать записи в любом порядке. Например, потребитель может вернуться к более старому смещению для повторной обработки данных или перейти к самой последней записи и начать считывание с настоящего момента.

Такое сочетание функций означает, что потребители **ADS** могут приходить и уходить без особого влияния на кластер и на других потребителей. Например, можно использовать инструменты командной строки для считывания с конца содержимого любого топика без какого-либо влияния на то, что считывается другими потребителями.

Партиции в журнале служат нескольким целям. Во-первых, они позволяют журналу масштабироваться сверх размера, который помещается на одном сервере. Каждая отдельная партиция располагается на конкретном сервере, но топик может иметь много партиций и располагаться на нескольких серверах для возможности обработки произвольного количества данных. Во-вторых, партиции действуют как единица параллелизма.

Партиции журнала распределяются по серверам кластера **ADS**, при этом каждый сервер обрабатывает данные и запросы чатсти партиций. Каждая партиция реплицируется на настраиваемое число серверов для обеспечения отказоустойчивости.

Каждая партиция имеет один сервер, который выступает в качетсве "лидера". Лидер обрабатывает все запросы на чтение и запись для партиции, а остальные сервера пассивно реплицируют изменения лидера. Если лидер выходит из строя, один из брокеров автоматически становится новым лидером. 

**ADS MirrorMaker** обеспечивает поддержку георепликации для кластеров. С помощью **MirrorMaker** сообщения реплицируются через несколько центров обработки данных или облачных сервисов. Это можно использовать в активных/пассивных сценариях резервного копирования и восстановления или в активных/активных сценариях для размещения данных ближе к пользователям или с целью поддержки требований к местоположению данных.

Поставщики публикуют данные по топикам по своему усмотрению и отвечают за выбор того, какую запись назначить для какой партиции. Это может быть сделано в циклическом режиме просто для балансировки нагрузки, или это может быть сделано в соответствии с какой-либо семантической функцией разбиения (например, на основе некоторого ключа в записи). 

Потребители относят себя к группе потребителей, и каждая запись, опубликованная в топике, доставляется каждому инстансу потребителя, группа которого подписана на данный топик. При этом инстансы потребителя могут находиться на отдельных процессах или на отдельных машинах. Если все инстансы потребителя имеют одну и ту же группу, то записи эффективно балансируются. А в случае если инстансы потребителя имеют разные группы, то каждая запись передается во все потребительские процессы (:numref:`Рис.%s.<ADS_intro_group>`).

.. _ADS_intro_group:

.. figure:: ./imgs/ADS_intro_group.*
   :align: center

   Группы потребителей 

На рисунке приведен пример двухсерверного кластера **ADS** с четырьмя партициями (*P0-P3*) и с двумя группами потребителей. Группа потребителей *A* имеет два экземпляра потребителей, группа *B* -- четыре.

Чаще всего топики имеют небольшое количество групп потребителей -- по одной для каждого "логического подписчика". Каждая группа состоит из множества инстансов потребителей для обеспечения масштабируемости и отказоустойчивости. Это не что иное, как семантика "издатель-подписчик", где подписчик представляет собой кластер потребителей, а не один процесс.

Реализация способа считывания в **ADS** заключается в разделении на партиции в журнале исходя из экземпляров потребителя, чтобы каждый экземпляр был исключительным потребителем "изрядной доли" партиций в любой момент времени. Процесс поддержания членства в группе динамически обрабатывается протоколом **ADS**. Если к группе присоединяются новые экземпляры, они принимают некоторые партиции от других членов группы; если экземпляр удаляется, его партиции распределяются по остальным экземплярам.

**ADS** предоставляет только общий порядок записей внутри партиции, а не между партициями в топике. Упорядочивание по разделам в сочетании с возможностью разбиения данных по ключам для большинства приложений является достаточным. Однако если требуется полный порядок по записям, это может быть достигнуто с помощью топика, имеющего только одну партицию, хотя это будет означать только один потребительский процесс для каждой группы потребителей.

**ADS** можно развернуть как *multi-tenant* решение. Мультиарендный режим включается путем настройки, в какой топик могут записывать данные, а из какого считываться. Существует также операционная поддержка квот. Администраторы могут определять и применять квоты на запросы для управления ресурсами брокера, которые используются клиентами.


Гарантии
^^^^^^^^^

На высоком уровне **ADS** дает следующие гарантии:

+ Сообщения, отправленные поставщиком в определенную партицию топика, добавляются в таком же порядке. То есть, если записи *M1* и *М2* отправляются одним поставщиком, и сначала отправляется *M1*, тогда *M1* имеет меньшее смещение, чем *M2*, и появляется в журнале раньше;
+ Инстанс потребителя видит записи в том же порядке, в котором они хранятся в журнале;
+ Для топика с коэффициентом репликации *N* допустимо до *N-1* сбоев сервера без потери записей, зафиксированных в журнале


Рекомендации по использованию
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ADS как Messaging System
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как понятие о потоках **ADS** сравнивается с традиционной корпоративной системой обмена сообщениями?

Обмен сообщениями традиционно имеет две модели: "очередь" и "публикация-подписка". В очереди группа потребителей может читать с сервера, и каждая запись переходит к одному из них; в модели "публикация-подписка" запись передается всем потребителям. 

Каждая из этих двух моделей имеет свои плюсы и минусы. Преимущество организации очереди заключается в том, что она допускает разделение обработки данных на несколько инстансов потребителей, что позволяет масштабировать обработку. Но при этом очереди не являются многопотребительскими -- как только один процесс считывает данные, они удаляются. Модель обмена сообщениями "публикация-подписка" позволяет передавать данные нескольким процессам, но при этом не имеет возможности масштабирования, так как каждое сообщение отправляется каждому подписчику.

Концепция группы потребителей в **ADS** обобщает эти две модели. Как и в случае с очередью, группа потребителей позволяет разделять обработку по совокупности процессов (по членам группы потребителей). А как в случае с моделью "публикация-подписка", **ADS** позволяет передавать сообщения нескольким группам потребителей.

Преимущество модели **ADS** заключается в том, что каждый топик имеет оба этих свойства -- он может масштабировать обработку, а также является многопотребитительским -- необходимость выбора той или иной модели отпадает.

К тому же **ADS** имеет более сильные гарантии упорядочения, чем традиционная система обмена сообщениями.

Традиционная очередь сохраняет записи на сервере по порядку, и передача записей с сервера осуществляется в порядке их хранения на нем. Однако если считывание из очереди производится несколькими потребителями, то, несмотря на то, что сервер ведет записи по порядку, данные доставляются потребителям асинхронно. Фактически это означает, что при параллельном считывании упорядоченность записей теряется. Системы обмена сообщениями часто обходят эту проблему, используя понятие "исключительный потребитель", которое позволяет только одному процессу считывать из очереди, но это говорит о том, что параллелизм в обработке отсутствует.

**ADS** эта проблема решена. Имея понятие "параллелизм -- партиция -- в рамках топика", **ADS** может обеспечить как гарантии упорядоченности, так и балансировку нагрузки над группами потребительских процессов. Это достигается путем назначения партиций в топике для потребителей соответствующей группы, чтобы каждая партиция считывалась ровно одним потребителем в группе. При этом гарантируется, что потребитель является единственным читателем этой партиции и потребляет данные по порядку. Поскольку существует много партиций, нагрузка балансируется по всем экземплярам потребителя. Также следует обратить внимание, что в группе не может быть экземпляров потребителей больше, чем партиций.


ADS как Storage System
~~~~~~~~~~~~~~~~~~~~~~~~

Любая очередь, которая позволяет публиковать сообщения, не связанные с их потреблением, эффективно может быть использована как система хранения *на лету* поступающих сообщений. Отличие платформы **ADS** заключается в том, что она является не только брокером сообщений, но и очень хорошей системой хранения данных.

Помещаемые в **ADS** данные записываются на диск и реплицируются для обеспечения отказоустойчивости. **ADS** позволяет поставщикам дождаться подтверждения операции, так что запись не считается полной, пока она не будет полностью реплицирована и гарантированно сохранена, даже если сервер вышел из строя.

Дисковые структуры **ADS** хорошо масштабируются: платформа функционирует одинаково, не зависимо от объема постоянных данных на сервере -- будь то *50 КБ* или *50 ТБ*.

С целью серьезного использования **ADS** в качестве хранилища и предоставления клиентам возможности контролирования позиции чтения, платформу можно рассматривать как своего рода распределенную файловую систему специального назначения, предназначенную для высокопроизводительного хранения данных с низкой задержкой коммитов в журнал, а так же для их репликации и распространения.


ADS -- Stream Processing
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Недостаточно просто читать, записывать и хранить потоки данных, важно обеспечить обработку потоков в реальном времени.

В **ADS** потоковый процессор -- это все, что принимает непрерывные потоки данных из входных топиков, выполняет некоторую обработку и создает непрерывные потоки данных в выходные топики.

Например, приложение розничной торговли может принимать входные потоки по продажам и отгрузкам и выводить поток с корректировками цен, вычисленными на основе входных данных.

Простую обработку можно выполнять напрямую, используя API-интерфейсы поставщика и потребителя. Однако для более сложных преобразований **ADS** предоставляет полностью интегрированный Streams API. Он позволяет создавать приложения с нетривиальной обработкой, выполняющей агрегацию потоков или объединяющей их вместе. Это помогает решить сложные проблемы, с которыми сталкивается подобный тип приложений: обработка неупорядоченных данных, переработка входных данных при изменении кода, выполнение вычислений с учетом состояния и т.д.

Streams API построен на основных примитивах **ADS**: он использует API-интерфейс поставщика и потребителя для ввода, использует Kafka для хранения состояний и применяет механизм группы для обеспечения отказоустойчивости среди инстансов потокового процессора.




