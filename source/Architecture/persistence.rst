Persistence
=================

**ADS** relies heavily on the filesystem for storing and caching messages. There is a general perception that "disks are slow" which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.

The key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a **JBOD** configuration with six *7200rpm* **SATA RAID-5** array is about *600MB/sec* but the performance of random writes is only about *100k/sec* -- a difference of over *6000X*. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this `ACM Queue <https://queue.acm.org/detail.cfm?id=1563874>`_ article; they actually find that sequential disk access can in some cases be faster than random memory access.

To compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.

Furthermore, the platform **ADS** building on top of the **JVM**, and anyone who has spent any time with **Java** memory usage knows two things:

+ The memory overhead of objects is very high, often doubling the size of the data stored (or worse);
+ Java garbage collection becomes increasingly fiddly and slow as the in-heap data increases.

As a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure -- we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to *28-30 GB* on a *32 GB* machine without GC penalties. Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a *10 GB* cache may take *10 minutes*) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.

This suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel's pagecache.

This style of pagecache-centric design is described in an article `Notes from the Architect <http://varnish-cache.org/docs/trunk/phk/notes.html>`_.

The persistent data structure used in messaging systems are often a per-consumer queue with an associated BTree or other general-purpose random access data structures to maintain metadata about messages. BTrees are the most versatile data structure available, and make it possible to support a wide variety of transactional and non-transactional semantics in the messaging system. They do come with a fairly high cost, though: Btree operations are *O(log N*). Normally *O(log N*) is considered essentially equivalent to constant time, but this is not true for disk operations. Disk seeks come at *10 ms* a pop, and each disk can do only one seek at a time so parallelism is limited. Hence even a handful of disk seeks leads to very high overhead. Since storage systems mix very fast cached operations with very slow physical disk operations, the observed performance of tree structures is often superlinear as data increases with fixed cache -- i.e. doubling your data makes things much worse than twice as slow.

Intuitively a persistent queue could be built on simple reads and appends to files as is commonly the case with logging solutions. This structure has the advantage that all operations are *O(1)* and reads do not block writes or each other. This has obvious performance advantages since the performance is completely decoupled from the data sizeâ€”one server can now take full advantage of a number of cheap, low-rotational speed *1+TB SATA* drives. Though they have poor seek performance, these drives have acceptable performance for large reads and writes and come at *1/3* the price and *3x* the capacity.

Having access to virtually unlimited disk space without any performance penalty means that **ADS** can provide some features not usually found in a messaging system. For example, in **ADS**, instead of attempting to delete messages as soon as they are consumed, can retain messages for a relatively long period (say a week). This leads to a great deal of flexibility for consumers.

